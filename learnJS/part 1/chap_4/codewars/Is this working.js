//https://www.codewars.com/kata/559f8d487fa8511c43000118/train/javascript

function Counter() {
  // this = {};
  this.count = 0;

  this.updateCount = () => {
    this.count++
  };
  // return this;
}

let counter = new Counter();
console.log(counter); // count 0

counter.updateCount.call({});
console.log('counter.updateCount.call:', counter.updateCount.call({});)
let fn = counter.updateCount;
fn();
console.log('fn():', fn();)
counter.count; // 2

/*
Ну например я делаю запросы на сервер и мне надо считать эти запросы - сколько я их сделал
Могу просто завести переменную requestCount = 0 и делать ей ++ после каждого запроса
А могу сделать const requestsCounter = new Counter() и делать .updateCount() каждый раз
Второй вариант изолирует логику внгутрь объекта
И вот тому кто делает инкремент уже все равно как именно он делается
Его задача вызывать .updateCount
А ++ там или +=25 уже не важно
Каунтер знает как инкременитить каунт
Тоту кому надо знает как попросить каунтер это сделать
Каждый занимается своим делом
Называется разделение ответственностей
Кроме того этот каунтер в таком случае - могут юзать несколько мест не дублируя логику инкремента (хоть она в данном случае и элементарная)
Плюс мы можем создавать в любом месте любое количество независимых каунтеров
Один путь запросы считает второй успешные запросы
*/